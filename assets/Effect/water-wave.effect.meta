{
  "ver": "1.0.27",
  "uuid": "0832870d-a729-4ec4-a711-f7b1ea6a62b9",
  "importer": "effect",
  "compiledShaders": [
    {
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}",
        "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\n#endif\nuniform vec4 cc_time;\nvarying vec4 v_color;\n#if USE_TEXTURE\nvarying vec2 v_uv0;\nuniform sampler2D texture;\n#endif\nuniform vec4 colors[6];\nuniform vec4 heights[6];\nuniform vec2 iResolution;\nuniform float skewAngle;\nuniform float waveType;\nvec2 tranPt(vec2 uv,float angle,vec2 center){\n  float c = cos(angle);\n  float s = sin(angle);\n  float Ox = center.x;\n  float Oy = center.y;\n  mat3 m = mat3(\n        c,0.0-s,(1.0-c)*Ox+s*Oy,\n        s,c,(1.0-c)*Oy-s*Ox,\n        0.0,0.0,1.0\n  );\n  vec3 ret = m*vec3(uv.x,uv.y,0.0);\n  return ret.xy;\n}\nfloat drawWater(vec2 uv,float angle,float _height,int arrSize,int curIdx)\n{\n  float ratio = iResolution.y/iResolution.x;\n  bool toLeft = sin(angle)>=0.0;\n  vec2 center = vec2(0.5,1.0-_height);\n  float _t = abs(tan(angle));\n  if(_height<0.5){\n    bool is_bottom = _t/ratio>2.0*_height;\n    if(is_bottom){\n      center.x = sqrt(2.0*_height/_t*ratio)/2.0;\n      center.y = 1.0 - sqrt(2.0*_height*_t/ratio)/2.0;\n      bool is_top = _t>(ratio)/(_height*2.0);\n      if(is_top){\n        center.y = 0.5;\n        center.x = _height;\n      }\n    }\n    if(!toLeft){\n      center.x = 1.0-center.x;\n    }\n  }else{\n    bool is_top = _t>2.0*ratio*(1.0-_height);\n    if(is_top){\n      center.x = sqrt(2.0*ratio*(1.0-_height)/_t)/2.0;\n      center.y = sqrt(2.0*ratio*(1.0-_height)*_t)/2.0/ratio;\n      bool is_bottom = _t>ratio/(2.0*(1.0-_height));\n      if(is_bottom){\n        center.y = 0.5;\n        center.x = 1.0-_height;\n      }\n    }\n    if(toLeft){\n      center.x = 1.0-center.x;\n    }\n  }\n  uv.y = uv.y*ratio;\n  uv -= vec2(center.x,center.y*ratio);\n  vec2 uv1 = tranPt(uv,angle,vec2(0.0));\n  float y = 0.0;\n  bool hasWave = curIdx==arrSize-1;\n  hasWave = hasWave;\n  if(hasWave){\n    float amplitude = 0.0;\n    float angularVelocity = 0.0;\n    float frequency = 0.0;\n    if(abs(waveType-1.0)<0.01){\n      amplitude = 0.04;\n      angularVelocity = 15.0;\n      frequency = 20.0;\n    }else if(abs(waveType-2.0)<0.01){\n      amplitude = 0.01;\n      angularVelocity = 10.0;\n      frequency = 15.0;\n    }\n    y = amplitude * sin((angularVelocity * uv1.x) + (frequency * cc_time.x)*(toLeft ? 1. : -1.));\n  }\n  float alpha = (uv1.y > y) ? 1.0 : 0.0;\n  return alpha;\n}\nvoid main () {\n  vec4 ret = vec4(1.0,1.0,1.0,1.0);\n  ret *= texture2D(texture, v_uv0);\n  if(ret.a == 0.0){\n    discard;\n  }\n  float angle = mod(skewAngle,360.0) * 3.14159265358979323846 / 180.0;\n  vec2 uv = vec2(v_uv0);\n  float a = 0.0;\n  float _height = 0.0;\n  int size = 0;\n  for(int i=0;i<6;i++){\n    if(heights[i].x<0.001){\n      continue;\n    }\n    size++;\n  }\n  for(int i=0;i<6;i++){\n    if(heights[i].x<0.001){\n      continue;\n    }\n    _height+=heights[i].x;\n    a += drawWater(uv,angle,_height,size,i);\n    if(a>0.0){\n        ret *= a*colors[i];\n        break;\n    }\n  }\n  if(a<0.001){\n    discard;\n  }\n  gl_FragColor = ret;\n}"
      },
      "glsl3": {
        "vert": "\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}",
        "frag": "\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nin vec4 v_color;\n#if USE_TEXTURE\nin vec2 v_uv0;\nuniform sampler2D texture;\n#endif\nuniform Properties {\n  vec4 colors[6];\n  vec4 heights[6];\n  vec2 iResolution;\n  float skewAngle;\n  float waveType;\n};\nvec2 tranPt(vec2 uv,float angle,vec2 center){\n  float c = cos(angle);\n  float s = sin(angle);\n  float Ox = center.x;\n  float Oy = center.y;\n  mat3 m = mat3(\n        c,0.0-s,(1.0-c)*Ox+s*Oy,\n        s,c,(1.0-c)*Oy-s*Ox,\n        0.0,0.0,1.0\n  );\n  vec3 ret = m*vec3(uv.x,uv.y,0.0);\n  return ret.xy;\n}\nfloat drawWater(vec2 uv,float angle,float _height,int arrSize,int curIdx)\n{\n  float ratio = iResolution.y/iResolution.x;\n  bool toLeft = sin(angle)>=0.0;\n  vec2 center = vec2(0.5,1.0-_height);\n  float _t = abs(tan(angle));\n  if(_height<0.5){\n    bool is_bottom = _t/ratio>2.0*_height;\n    if(is_bottom){\n      center.x = sqrt(2.0*_height/_t*ratio)/2.0;\n      center.y = 1.0 - sqrt(2.0*_height*_t/ratio)/2.0;\n      bool is_top = _t>(ratio)/(_height*2.0);\n      if(is_top){\n        center.y = 0.5;\n        center.x = _height;\n      }\n    }\n    if(!toLeft){\n      center.x = 1.0-center.x;\n    }\n  }else{\n    bool is_top = _t>2.0*ratio*(1.0-_height);\n    if(is_top){\n      center.x = sqrt(2.0*ratio*(1.0-_height)/_t)/2.0;\n      center.y = sqrt(2.0*ratio*(1.0-_height)*_t)/2.0/ratio;\n      bool is_bottom = _t>ratio/(2.0*(1.0-_height));\n      if(is_bottom){\n        center.y = 0.5;\n        center.x = 1.0-_height;\n      }\n    }\n    if(toLeft){\n      center.x = 1.0-center.x;\n    }\n  }\n  uv.y = uv.y*ratio;\n  uv -= vec2(center.x,center.y*ratio);\n  vec2 uv1 = tranPt(uv,angle,vec2(0.0));\n  float y = 0.0;\n  bool hasWave = curIdx==arrSize-1;\n  hasWave = hasWave;\n  if(hasWave){\n    float amplitude = 0.0;\n    float angularVelocity = 0.0;\n    float frequency = 0.0;\n    if(abs(waveType-1.0)<0.01){\n      amplitude = 0.04;\n      angularVelocity = 15.0;\n      frequency = 20.0;\n    }else if(abs(waveType-2.0)<0.01){\n      amplitude = 0.01;\n      angularVelocity = 10.0;\n      frequency = 15.0;\n    }\n    y = amplitude * sin((angularVelocity * uv1.x) + (frequency * cc_time.x)*(toLeft ? 1. : -1.));\n  }\n  float alpha = (uv1.y > y) ? 1.0 : 0.0;\n  return alpha;\n}\nvoid main () {\n  vec4 ret = vec4(1.0,1.0,1.0,1.0);\n  ret *= texture(texture, v_uv0);\n  if(ret.a == 0.0){\n    discard;\n  }\n  float angle = mod(skewAngle,360.0) * 3.14159265358979323846 / 180.0;\n  vec2 uv = vec2(v_uv0);\n  float a = 0.0;\n  float _height = 0.0;\n  int size = 0;\n  for(int i=0;i<6;i++){\n    if(heights[i].x<0.001){\n      continue;\n    }\n    size++;\n  }\n  for(int i=0;i<6;i++){\n    if(heights[i].x<0.001){\n      continue;\n    }\n    _height+=heights[i].x;\n    a += drawWater(uv,angle,_height,size,i);\n    if(a>0.0){\n        ret *= a*colors[i];\n        break;\n    }\n  }\n  if(a<0.001){\n    discard;\n  }\n  gl_FragColor = ret;\n}"
      }
    }
  ],
  "subMetas": {}
}